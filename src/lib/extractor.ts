import { writeFileSync, mkdirSync, rmSync, existsSync } from 'node:fs';
import { join, resolve } from 'node:path';
import crypto from 'node:crypto';
import yaml from 'js-yaml';
import { fileURLToPath } from 'node:url';
import { sparseCheckout } from './git.js';
import { buildSchemaTree } from './child-expansion.js';
import { ResponsesFile, ResponseEntry, SchemaGroup, ExtractConfig, ResolvedExtractConfig } from '../types/index.js';
import { buildConfig } from './config.js';

// Backwards compatibility defaults retained via config module default values

function resolveResponse(resp: any, doc: any): any {
  if (resp && resp.$ref) { const refName = resp.$ref.split('/').pop(); return doc.components?.responses?.[refName!] || resp; }
  return resp;
}

export function extractResponses(doc: any): ResponseEntry[] {
  const entries: ResponseEntry[] = [];
  const paths = doc.paths || {};
  for (const [path, pathItem] of Object.entries<any>(paths)) {
    for (const method of ['get','post','put','patch','delete']) {
      const op = (pathItem as any)[method];
      if (!op) continue;
      const responses = op.responses || {};
      for (const [status, response] of Object.entries<any>(responses)) {
        const resolved = resolveResponse(response, doc);
        const content = resolved?.content;
        const appJson = content?.['application/json'];
        const schema = appJson?.schema;
        if (!schema) continue;
        const flattened = buildSchemaTree(schema, doc.components?.schemas || {});
        entries.push({ path, method: method.toUpperCase(), status, schema: { required: flattened.required, optional: flattened.optional } });
      }
    }
  }
  return entries;
}

export function pruneSchema(schema: SchemaGroup) {
  const visit = (sch: SchemaGroup) => {
    for (const group of [sch.required, sch.optional]) {
      for (const field of group) {
        if (field.children) {
          visit(field.children);
          if (field.children.required.length === 0 && field.children.optional.length === 0) {
            delete field.children;
          }
        }
      }
    }
  };
  visit(schema);
}

export async function generate(cfg?: ExtractConfig) {
  // Resolve configuration (allows direct call with partial overrides)
  const resolution = buildConfig();
  const base = resolution.resolved.extract;
  const effective: ResolvedExtractConfig = {
    repo: cfg?.repo || base.repo,
    specPath: cfg?.specPath || base.specPath,
    ref: cfg?.ref || base.ref,
    outputDir: cfg?.outputDir || base.outputDir,
    preserveCheckout: cfg?.preserveCheckout ?? base.preserveCheckout,
    dryRun: cfg?.dryRun ?? base.dryRun,
    logLevel: (cfg?.logLevel as any) || base.logLevel,
    failIfExists: cfg?.failIfExists ?? base.failIfExists,
    responsesFile: cfg?.responsesFile || base.responsesFile,
  };
  const REPO = effective.repo;
  const SPEC_PATH = effective.specPath;
  const { workdir, commit, specContent } = sparseCheckout(REPO, SPEC_PATH, effective.ref);
  try {
    const doc: any = yaml.load(specContent);
    const responses = extractResponses(doc);
    for (const entry of responses) pruneSchema(entry.schema);
    const sha256 = crypto.createHash('sha256').update(specContent).digest('hex');
    const out: ResponsesFile = { metadata: { sourceRepo: REPO, commit, generatedAt: new Date().toISOString(), specPath: SPEC_PATH, specSha256: sha256 }, responses };
  const outDir = effective.outputDir;
  const targetFile = effective.responsesFile ? resolve(effective.responsesFile) : join(outDir, 'responses.json');
    if (effective.failIfExists && existsSync(targetFile)) {
      throw new Error(`Target file already exists: ${targetFile}`);
    }
    if (!effective.dryRun) {
      mkdirSync(outDir, { recursive: true });
      writeFileSync(targetFile, JSON.stringify(out, null, 2));
      // Emit TypeScript index.ts with strongly-typed validateResponseShape wrapper
      try {
        const routeIndex: Record<string, Record<string, Record<string, 1>>> = {};
        for (const r of responses) {
          if (!routeIndex[r.path]) routeIndex[r.path] = {};
          if (!routeIndex[r.path][r.method]) routeIndex[r.path][r.method] = {};
          routeIndex[r.path][r.method][r.status] = 1;
        }
        const indexSource = `/* Auto-generated by assert-json-body extract. Do not edit manually. */\n` +
          `import { validateResponseShape as _baseValidateResponseShape } from 'assert-json-body/base';\n\n` +
          `export const RESPONSE_INDEX = ${JSON.stringify(routeIndex, null, 2)} as const;\n\n` +
          `export type RoutePath = keyof typeof RESPONSE_INDEX;\n` +
          `export type MethodFor<P extends RoutePath> = Extract<keyof typeof RESPONSE_INDEX[P], string>;\n` +
          `export type StatusFor<P extends RoutePath, M extends MethodFor<P>> = Extract<keyof typeof RESPONSE_INDEX[P][M], string>;\n\n` +
          `export interface TypedRouteSpec<P extends RoutePath = RoutePath, M extends MethodFor<P> = MethodFor<P>, S extends StatusFor<P, M> = StatusFor<P, M>> {\n` +
          `  path: P;\n  method: M;\n  status: S;\n}` + '\n\n' +
          `export function validateResponseShape<P extends RoutePath, M extends MethodFor<P>, S extends StatusFor<P,M>>(spec: { path: P; method: M; status: S }, body: unknown, options?: { responsesFilePath?: string; configPath?: string; throw?: boolean; record?: boolean | { label?: string } }) {\n` +
          `  // Cast to base signature (method/status widened to string) for internal call.\n` +
          `  const baseFn: any = _baseValidateResponseShape;\n` +
      `  if (baseFn === (validateResponseShape as any)) {\n` +
      `    throw new Error(
"Typed validator resolved to itself. Avoid aliasing the package name to the generated typed file. Use a relative import to the generated ./assert-json-body/index or import from 'assert-json-body/base' for the core API."
  );\n` +
          `  }\n` +
          `  return baseFn(spec as unknown as { path: string; method?: string; status?: string }, body, options);\n}` + '\n';
        writeFileSync(join(outDir, 'index.ts'), indexSource);
      } catch (e) {
        if (effective.logLevel === 'debug') console.warn('Failed to emit typed index.ts:', (e as Error).message);
      }
    }
    if (effective.logLevel !== 'silent') {
      console.log(`Extracted ${responses.length} response schemas from commit ${commit}` + (effective.dryRun ? ' (dry-run: no files written)' : ''));
      if (effective.responsesFile && effective.logLevel === 'debug') {
        console.log(`Responses file explicit: ${targetFile}`);
      }
      if (resolution.warnings.length) { for (const w of resolution.warnings) console.warn(`[config] ${w}`); }
    }
  } finally {
    if (effective.preserveCheckout) {
      if (effective.logLevel === 'debug') console.log('Preserving temporary spec checkout.');
    } else { try { rmSync(workdir, { recursive: true, force: true }); } catch {} }
  }
}

// Runtime main guard (ESM safe). For CJS compiled output we skip auto-exec to avoid import.meta requirement.
try {
  // Access import.meta.url only in ESM environments.
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  const thisUrl: string | undefined = typeof import.meta !== 'undefined' ? import.meta.url : undefined;
  if (thisUrl) {
    const isMain = process.argv[1] && fileURLToPath(thisUrl) === process.argv[1];
    if (isMain) { generate(); }
  }
} catch { /* ignore */ }
